#!/usr/bin/env bash
set -euo pipefail

# Devbox - Simple Elastic GCP Development Machine
# Main entry point for devbox commands

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEVBOX_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Default values
DEFAULT_DISK_SIZE_GB=300
DEFAULT_DISK_TYPE="pd-balanced"
DEFAULT_IDLE_TIMEOUT_MINUTES=10
DEFAULT_OS_IMAGE="ubuntu-2204-jammy-v20240111"  # Ubuntu 22.04 LTS
DEFAULT_MOUNT_POINT="/mnt/dev"

# Get username for default VM/disk naming
USERNAME="${USER:-$(whoami)}"

# Global config path
GLOBAL_CONFIG_DIR="${HOME}/.devbox"
GLOBAL_CONFIG_FILE="${GLOBAL_CONFIG_DIR}/config.json"

# Project config path (relative to current directory)
PROJECT_CONFIG_FILE=".devbox/config.json"

# Source utility functions
source "${SCRIPT_DIR}/../scripts/lib/config.sh"
source "${SCRIPT_DIR}/../scripts/lib/gcp.sh"
source "${SCRIPT_DIR}/../scripts/lib/vm.sh"
source "${SCRIPT_DIR}/../scripts/lib/ssh.sh"

usage() {
    cat <<EOF
Usage: devbox <command> [options]

Commands:
    bootstrap            Set up devbox for the current project
    status               Show VM and disk status
    start                Manually start the VM
    stop                 Manually stop the VM
    ssh                  Connect to the VM via SSH
    update-idle-shutdown Update the idle shutdown service on existing VM
    teardown [--keep-disk]  Delete VM (and optionally persistent disk)
    help                 Show this help message

Examples:
    devbox bootstrap    # Set up devbox for current project
    devbox status       # Check if VM is running
    devbox ssh          # Connect to VM
EOF
}

cmd_bootstrap() {
    echo "üöÄ Devbox Bootstrap"
    echo "==================="
    echo ""

    # 1. Read configuration files first (needed for GCP_PROJECT)
    echo "üìñ Reading configuration..."
    load_global_config
    load_project_config
    echo "‚úì Configuration loaded"
    echo ""

    # 2. Validate environment (uses GCP_PROJECT from config)
    echo "üìã Validating environment..."
    validate_environment || exit 1
    echo "‚úì Environment validated"
    echo ""

    # 3. Ensure shared persistent disk exists
    echo "üíæ Ensuring persistent disk exists..."
    ensure_disk_exists || exit 1
    echo "‚úì Disk ready: ${DISK_NAME}"
    echo ""

    # 4. Ensure shared VM exists
    echo "üñ•Ô∏è  Ensuring VM exists..."
    ensure_vm_exists || exit 1
    echo "‚úì VM ready: ${VM_NAME}"
    echo ""

    # 5. Create project directory on persistent disk
    echo "üìÅ Creating project directory..."
    create_project_directory || exit 1
    echo "‚úì Project directory ready: ${PROJECT_DIR}"
    echo ""

    # 6. Install idle shutdown on VM (if needed)
    echo "‚è∞ Ensuring idle shutdown service is installed..."
    install_idle_shutdown || exit 1
    echo "‚úì Idle shutdown service ready"
    echo ""

    # 7. Configure local SSH auto-start
    echo "üîå Configuring SSH..."
    configure_ssh || exit 1
    echo "‚úì SSH configured"
    echo ""

    echo ""
    echo "‚úÖ Bootstrap complete!"
    echo ""
    echo "Next steps:"
    echo "  1. Open VS Code / Cursor"
    echo "  2. Connect to Remote SSH: ${VM_NAME}"
    echo "  3. Open folder: ${PROJECT_DIR}"
    echo ""
}

cmd_status() {
    load_global_config
    check_vm_status
}

cmd_start() {
    load_global_config
    start_vm
}

cmd_stop() {
    load_global_config
    stop_vm
}

cmd_ssh() {
    load_global_config
    ssh_to_vm "$@"
}

cmd_update_idle_shutdown() {
    load_global_config
    
    local vm_status=$(get_vm_status)
    if [[ "$vm_status" != "RUNNING" ]]; then
        echo "VM is not running. Starting it..."
        start_vm
    fi
    
    echo "Updating idle shutdown service on VM..."
    
    # Create a temporary script file with the updated content
    local temp_script=$(mktemp)
    cat > "$temp_script" <<'SCRIPT_EOF'
#!/bin/bash
IDLE_TIMEOUT_MINUTES=10
IDLE_TIMEOUT_SECONDS=$((IDLE_TIMEOUT_MINUTES * 60))
TIMESTAMP_FILE="/tmp/devbox-last-ssh-activity"
LOG_FILE="/var/log/devbox-idle-shutdown.log"

# Logging function
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Update timestamp
update_timestamp() {
    echo $(date +%s) > "$TIMESTAMP_FILE"
}

# Check for active SSH sessions - use multiple methods for reliability
check_active_sessions() {
    sessions=0
    
    # Method 1: Check for active pseudo-terminals (SSH sessions) - PRIMARY METHOD
    # This is the most reliable - actual user sessions show up in 'who'
    if command -v who >/dev/null 2>&1; then
        session_count=$(who | grep -c "pts/" 2>/dev/null || echo "0")
        # Ensure it's a number, default to 0 if not, and strip whitespace
        session_count=$(echo "$session_count" | tr -d '[:space:]')
        if [ -z "$session_count" ] || ! [ "$session_count" -eq "$session_count" ] 2>/dev/null; then
            session_count=0
        fi
        sessions=$session_count
    fi
    
    # Only use fallback methods if 'who' shows no sessions
    # (IAP tunnel connections don't show up in 'who', so we need to be careful)
    if [ $sessions -eq 0 ] && command -v pgrep >/dev/null 2>&1; then
        # Check for SSH processes serving user sessions (sshd: user@pts)
        # This is more reliable than checking network connections
        sshd_count=$(pgrep -f "sshd:.*@pts" 2>/dev/null | wc -l)
        sshd_count=$(echo "$sshd_count" | tr -d '[:space:]')
        if [ -z "$sshd_count" ] || ! [ "$sshd_count" -eq "$sshd_count" ] 2>/dev/null; then
            sshd_count=0
        fi
        if [ $sshd_count -gt 0 ]; then
            sessions=$sshd_count
        fi
    fi
    
    # Ensure we return a clean integer (no whitespace)
    echo $sessions
}

# Initialize
update_timestamp
log_message "Idle shutdown service started (timeout: ${IDLE_TIMEOUT_MINUTES} minutes)"
LAST_SESSION_COUNT=0

while true; do
    # Check for active SSH sessions
    ACTIVE_SESSIONS=$(check_active_sessions)
    # Ensure ACTIVE_SESSIONS is a clean integer (handle empty/whitespace)
    ACTIVE_SESSIONS=$(echo "$ACTIVE_SESSIONS" | tr -d '[:space:]')
    if [ -z "$ACTIVE_SESSIONS" ] || ! [ "$ACTIVE_SESSIONS" -eq "$ACTIVE_SESSIONS" ] 2>/dev/null; then
        ACTIVE_SESSIONS=0
    fi
    
    if [ $ACTIVE_SESSIONS -gt 0 ]; then
        # Active sessions exist
        if [ $LAST_SESSION_COUNT -eq 0 ]; then
            # Just transitioned from no sessions to having sessions
            log_message "SSH session detected (count: $ACTIVE_SESSIONS)"
        fi
        update_timestamp
        LAST_SESSION_COUNT=$ACTIVE_SESSIONS
    else
        # No active sessions
        if [ $LAST_SESSION_COUNT -gt 0 ]; then
            # Just transitioned from having sessions to no sessions
            log_message "All SSH sessions disconnected. Starting idle timer."
            update_timestamp  # Set timestamp to now when sessions disconnect
        fi
        
        # Check idle time since last activity
        if [ -f "$TIMESTAMP_FILE" ]; then
            LAST_ACTIVITY=$(cat "$TIMESTAMP_FILE")
            NOW=$(date +%s)
            IDLE_SECONDS=$((NOW - LAST_ACTIVITY))
            IDLE_MINUTES=$((IDLE_SECONDS / 60))
            
            # Log every 5 minutes when idle
            if [ $((IDLE_SECONDS % 300)) -lt 60 ]; then
                log_message "Idle for ${IDLE_MINUTES} minutes (${IDLE_TIMEOUT_MINUTES} minute timeout)"
            fi
            
            if [ "$IDLE_SECONDS" -ge "$IDLE_TIMEOUT_SECONDS" ]; then
                log_message "Idle timeout reached (${IDLE_MINUTES} minutes). Stopping VM..."
                
                # Get VM name, zone, and project from metadata
                VM_NAME=$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/name)
                ZONE=$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/zone | sed 's/.*\///')
                PROJECT=$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/project/project-id)
                
                # Try using gcloud first (simpler and more reliable)
                if command -v gcloud >/dev/null 2>&1 && [ -n "$VM_NAME" ] && [ -n "$ZONE" ] && [ -n "$PROJECT" ]; then
                    log_message "Stopping VM using gcloud: $VM_NAME in zone $ZONE"
                    if gcloud compute instances stop "$VM_NAME" --zone="$ZONE" --project="$PROJECT" --quiet 2>&1 | tee -a "$LOG_FILE"; then
                        log_message "VM stop command sent successfully via gcloud"
                        sleep 2
                        exit 0
                    else
                        log_message "gcloud stop command failed, trying REST API..."
                    fi
                fi
                
                # Fallback to REST API
                TOKEN_RESPONSE=$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token)
                ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | sed -n 's/.*"access_token":"\([^"]*\)".*/\1/p')
                
                if [ -n "$ACCESS_TOKEN" ] && [ -n "$VM_NAME" ] && [ -n "$ZONE" ] && [ -n "$PROJECT" ]; then
                    log_message "Stopping VM using REST API: $VM_NAME in zone $ZONE"
                    RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X POST \
                        -H "Authorization: Bearer $ACCESS_TOKEN" \
                        "https://compute.googleapis.com/compute/v1/projects/$PROJECT/zones/$ZONE/instances/$VM_NAME/stop")
                    
                    HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
                    RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')
                    
                    if [ "$HTTP_CODE" = "200" ] || echo "$RESPONSE_BODY" | grep -q '"status":"DONE"'; then
                        log_message "VM stop request sent successfully (HTTP $HTTP_CODE)"
                        sleep 2
                        exit 0
                    else
                        log_message "API call failed (HTTP $HTTP_CODE): $RESPONSE_BODY"
                        log_message "Falling back to systemctl poweroff"
                        systemctl poweroff || shutdown -h now
                    fi
                else
                    log_message "Failed to get metadata or access token, using systemctl poweroff"
                    systemctl poweroff || shutdown -h now
                fi
                exit 0
            fi
        fi
        LAST_SESSION_COUNT=0
    fi
    
    sleep 60
done
SCRIPT_EOF
    
    # Transfer and install the script on the VM
    gcloud compute scp "$temp_script" "${VM_NAME}:/tmp/devbox-idle-shutdown.sh" \
        --zone="$ZONE" \
        --project="$GCP_PROJECT" \
        --tunnel-through-iap \
        --quiet || {
        echo "‚ö†Ô∏è  Failed to transfer script to VM"
        rm -f "$temp_script"
        return 1
    }
    
    # Install and restart the service
    gcloud compute ssh "$VM_NAME" --zone="$ZONE" --project="$GCP_PROJECT" \
        --tunnel-through-iap \
        --command="sudo mv /tmp/devbox-idle-shutdown.sh /usr/local/bin/devbox-idle-shutdown.sh && sudo chmod +x /usr/local/bin/devbox-idle-shutdown.sh && sudo systemctl restart devbox-idle-shutdown.service && sudo systemctl status devbox-idle-shutdown.service --no-pager -l" \
        --quiet || {
        echo "‚ö†Ô∏è  Failed to update idle shutdown service"
        rm -f "$temp_script"
        return 1
    }
    
    rm -f "$temp_script"
    echo "‚úì Idle shutdown service updated and restarted"
    echo "  Check logs with: devbox ssh 'sudo tail -f /var/log/devbox-idle-shutdown.log'"
}

cmd_teardown() {
    load_global_config
    
    # Check for --keep-disk flag
    KEEP_DISK=false
    if [[ "$1" == "--keep-disk" ]]; then
        KEEP_DISK=true
    fi
    
    # Confirm before proceeding
    echo ""
    echo "‚ö†Ô∏è  ‚ö†Ô∏è  ‚ö†Ô∏è   DESTRUCTIVE OPERATION   ‚ö†Ô∏è  ‚ö†Ô∏è  ‚ö†Ô∏è"
    echo ""
    echo "This will PERMANENTLY DELETE:"
    echo "   - VM: ${VM_NAME}"
    if [[ "$KEEP_DISK" == "true" ]]; then
        echo "   - Persistent disk: ${DISK_NAME} (WILL BE PRESERVED)"
    else
        echo "   - Persistent disk: ${DISK_NAME}"
        echo "   - ALL data on the persistent disk"
    fi
    echo ""
    if [[ "$KEEP_DISK" != "true" ]]; then
        echo "‚ö†Ô∏è  WARNING: Disk deletion is PERMANENT and CANNOT be undone!"
        echo "   Use 'devbox teardown --keep-disk' to preserve the disk"
    fi
    echo ""
    read -p "Type 'DELETE' to confirm teardown: " confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo ""
        echo "Teardown cancelled. No resources were deleted."
        return 0
    fi
    
    echo ""
    echo "Deleting VM: ${VM_NAME}"
    if gcloud compute instances delete "$VM_NAME" \
        --zone="$ZONE" \
        --project="$GCP_PROJECT" \
        --delete-disks=boot \
        --quiet; then
        echo "‚úì VM deleted"
    else
        echo "‚ö†Ô∏è  VM deletion failed or VM does not exist"
    fi
    
    if [[ "$KEEP_DISK" == "true" ]]; then
        echo ""
        echo "‚úì Persistent disk preserved: ${DISK_NAME}"
        echo "   You can attach it to a new VM later"
    else
        echo ""
        echo "Deleting persistent disk: ${DISK_NAME}"
        if gcloud compute disks delete "$DISK_NAME" \
            --zone="$ZONE" \
            --project="$GCP_PROJECT" \
            --quiet; then
            echo "‚úì Persistent disk deleted"
        else
            echo "‚ö†Ô∏è  Disk deletion failed or disk does not exist"
        fi
    fi
    
    echo ""
    echo "‚úì All resources deleted"
}

# Main command dispatcher
case "${1:-help}" in
    bootstrap)
        cmd_bootstrap
        ;;
    status)
        cmd_status
        ;;
    start)
        cmd_start
        ;;
    stop)
        cmd_stop
        ;;
    ssh)
        shift
        cmd_ssh "$@"
        ;;
    teardown)
        cmd_teardown "$2"
        ;;
    update-idle-shutdown)
        cmd_update_idle_shutdown
        ;;
    help|--help|-h)
        usage
        ;;
    *)
        echo "Unknown command: $1"
        echo ""
        usage
        exit 1
        ;;
esac
