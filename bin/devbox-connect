#!/usr/bin/env bash
# SSH ProxyCommand wrapper that auto-starts the VM

set -euo pipefail

# Load global config
GLOBAL_CONFIG_FILE="${HOME}/.devbox/config.json"

if [[ ! -f "$GLOBAL_CONFIG_FILE" ]]; then
    echo "Error: Devbox not configured. Run 'devbox bootstrap' first." >&2
    exit 1
fi

# Parse config (with or without jq)
if command -v jq &> /dev/null; then
    GCP_PROJECT=$(jq -r '.gcpProject // empty' "$GLOBAL_CONFIG_FILE")
    VM_NAME=$(jq -r '.vmName' "$GLOBAL_CONFIG_FILE")
    ZONE=$(jq -r '.zone' "$GLOBAL_CONFIG_FILE")
else
    GCP_PROJECT=$(grep -o '"gcpProject": *"[^"]*"' "$GLOBAL_CONFIG_FILE" | cut -d'"' -f4)
    VM_NAME=$(grep -o '"vmName": *"[^"]*"' "$GLOBAL_CONFIG_FILE" | cut -d'"' -f4)
    ZONE=$(grep -o '"zone": *"[^"]*"' "$GLOBAL_CONFIG_FILE" | cut -d'"' -f4)
fi

# Fallback to gcloud config if not in devbox config (for backward compatibility)
if [[ -z "$GCP_PROJECT" ]]; then
    GCP_PROJECT=$(gcloud config get-value project 2>/dev/null)
fi

if [[ -z "$GCP_PROJECT" ]]; then
    echo "Error: No GCP project configured. Run 'devbox bootstrap' first." >&2
    exit 1
fi

# Verify we're using the project from config (not gcloud default)
if [[ "${DEBUG_DEVBOX:-}" == "1" ]]; then
    echo "Devbox-connect: Using project '$GCP_PROJECT', VM '$VM_NAME', Zone '$ZONE'" >&2
fi

# Check VM status
VM_STATUS=$(gcloud compute instances describe "$VM_NAME" \
    --zone="$ZONE" \
    --project="$GCP_PROJECT" \
    --format="value(status)" 2>/dev/null || echo "NOT_FOUND")

if [[ "$VM_STATUS" == "NOT_FOUND" ]]; then
    echo "Error: VM ${VM_NAME} not found. Run 'devbox bootstrap' first." >&2
    exit 1
fi

# Start VM if not running
if [[ "$VM_STATUS" != "RUNNING" ]]; then
    echo "Starting VM ${VM_NAME}..." >&2
    gcloud compute instances start "$VM_NAME" --zone="$ZONE" --project="$GCP_PROJECT" --quiet
    
    # Wait for VM to be RUNNING (don't test SSH here - that blocks ProxyCommand)
    # The actual SSH connection will handle SSH readiness
    echo "Waiting for VM to start (this may take 30-60 seconds)..." >&2
    max_attempts=60  # 2 minutes max wait
    attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        CURRENT_STATUS=$(gcloud compute instances describe "$VM_NAME" \
            --zone="$ZONE" \
            --project="$GCP_PROJECT" \
            --format="value(status)" 2>/dev/null || echo "UNKNOWN")
        
        if [[ "$CURRENT_STATUS" == "RUNNING" ]]; then
            # VM is running, wait for SSH service to fully start
            # SSH service typically takes 15-30 seconds after VM status is RUNNING
            echo "VM is running, waiting for SSH service (this may take 20-40 seconds)..." >&2
            # Wait 30 seconds for SSH to be ready, with progress updates
            for ssh_wait in $(seq 1 10); do
                sleep 3
                if [ $((ssh_wait % 3)) -eq 0 ]; then
                    echo "Still waiting for SSH service... ($((ssh_wait * 3))s)" >&2
                fi
            done
            echo "SSH service should be ready, establishing connection..." >&2
            break
        fi
        
        attempt=$((attempt + 1))
        if [ $((attempt % 5)) -eq 0 ]; then
            echo "Still waiting for VM to start... ($attempt/$max_attempts)" >&2
        fi
        sleep 2
    done
    
    if [ $attempt -ge $max_attempts ]; then
        echo "Error: VM failed to start within timeout" >&2
        exit 1
    fi
fi

# Proxy the connection via IAP tunnel
# Use gcloud compute start-iap-tunnel with --listen-on-stdin
# This is the correct way to use IAP tunnel as a ProxyCommand
# Always use port 22 (SSH port on VM), ignore %p from SSH config
exec gcloud compute start-iap-tunnel "$VM_NAME" 22 \
    --zone="$ZONE" \
    --project="$GCP_PROJECT" \
    --listen-on-stdin \
    --verbosity=warning
